<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>マインドマップ - プロジェクト計画</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { width: 100%; height: 100%; overflow: hidden; font-family: 'Segoe UI', 'Hiragino Sans', sans-serif; background: #1a1a2e; }
#container { width: 100%; height: 100%; cursor: grab; }
#container.grabbing { cursor: grabbing; }
svg { width: 100%; height: 100%; }
.node-group { cursor: grab; }
.node-group.dragging { cursor: grabbing; }
.node-rect.drop-target { stroke: #fff !important; stroke-width: 3 !important; stroke-dasharray: 6 3; filter: brightness(1.5) drop-shadow(0 0 12px rgba(255,255,255,0.6)) !important; }
.node-rect { rx: 12; ry: 12; stroke-width: 2; transition: filter 0.2s; }
.node-group:hover .node-rect { filter: brightness(1.2) drop-shadow(0 0 8px rgba(255,255,255,0.3)); }
.node-text { fill: #fff; font-weight: 600; text-anchor: middle; dominant-baseline: central; pointer-events: none; user-select: none; }
.branch-line { fill: none; stroke-width: 3; stroke-linecap: round; opacity: 0.7; }
.anchor-dot { cursor: crosshair; opacity: 0; transition: opacity 0.15s; }
.anchor-dot:hover { opacity: 1 !important; }
.resize-handle { cursor: ew-resize; opacity: 0; transition: opacity 0.15s; }
.node-group:hover .resize-handle { opacity: 0.8; }
.badge { pointer-events: none; user-select: none; }
.badge rect { rx: 8; ry: 8; }
.badge text { fill: #fff; font-size: 10px; font-weight: 700; text-anchor: middle; dominant-baseline: central; }
.ctx-menu { position: fixed; display: none; background: rgba(20,20,45,0.96); border: 1px solid rgba(255,255,255,0.15); border-radius: 10px; padding: 6px 0; z-index: 200; min-width: 170px; backdrop-filter: blur(12px); box-shadow: 0 8px 30px rgba(0,0,0,0.5); }
.ctx-menu.show { display: block; }
.ctx-item { padding: 9px 18px; color: #ddd; cursor: pointer; font-size: 14px; font-family: inherit; display: flex; align-items: center; gap: 8px; }
.ctx-item:hover { background: rgba(255,255,255,0.12); color: #fff; }
.ctx-item:first-child { border-radius: 10px 10px 0 0; }
.ctx-item:last-child { border-radius: 0 0 10px 10px; }
.ctx-sep { height: 1px; background: rgba(255,255,255,0.1); margin: 4px 0; }
.controls { position: fixed; bottom: 20px; right: 20px; display: flex; gap: 8px; z-index: 10; }
.controls button { width: 40px; height: 40px; border: none; border-radius: 10px; background: rgba(255,255,255,0.15); color: #fff; font-size: 18px; cursor: pointer; backdrop-filter: blur(8px); transition: background 0.2s; }
.controls button:hover { background: rgba(255,255,255,0.3); }
.hint { position: fixed; top: 16px; left: 50%; transform: translateX(-50%); color: rgba(255,255,255,0.5); font-size: 13px; pointer-events: none; z-index: 10; }
.edit-input { position: fixed; border: 2px solid #fff; border-radius: 8px; background: rgba(30,30,60,0.95); color: #fff; font-weight: 600; text-align: center; outline: none; z-index: 100; padding: 4px 8px; }
.node-rect.selected { stroke: #5bf !important; stroke-width: 3 !important; filter: drop-shadow(0 0 8px rgba(85,187,255,0.5)) !important; }
#select-box { fill: rgba(85,187,255,0.1); stroke: rgba(85,187,255,0.6); stroke-width: 1.5; stroke-dasharray: 5 3; pointer-events: none; }
.ctx-color-label { padding: 4px 18px 2px; color: rgba(255,255,255,0.5); font-size: 11px; }
.ctx-color-grid { display: flex; flex-wrap: wrap; gap: 6px; padding: 6px 18px 8px; }
.color-dot { width: 20px; height: 20px; border-radius: 50%; cursor: pointer; border: 2px solid transparent; transition: border-color 0.15s, transform 0.1s; flex-shrink: 0; }
.color-dot:hover { border-color: #fff; transform: scale(1.2); }
.color-dot.active { border-color: #fff; }
.color-custom { width: 20px; height: 20px; border-radius: 50%; cursor: pointer; border: 2px dashed rgba(255,255,255,0.4); background: conic-gradient(red,yellow,lime,aqua,blue,magenta,red); flex-shrink: 0; overflow: hidden; position: relative; }
.color-custom input { position: absolute; inset: 0; opacity: 0; cursor: pointer; width: 100%; height: 100%; }
.controls button.active { background: rgba(85,187,255,0.5); box-shadow: 0 0 8px rgba(85,187,255,0.4); }
#container.arrow-mode { cursor: crosshair; }
#container.arrow-mode.grabbing { cursor: crosshair; }
.free-arrow-path { fill: none; stroke-linecap: round; cursor: pointer; }
.free-arrow-hit { fill: none; stroke: transparent; stroke-width: 14; cursor: pointer; }
.free-arrow-handle { cursor: grab; }
.free-arrow-handle:hover { filter: brightness(1.3); }
.arrow-ctx-menu { position: fixed; display: none; background: rgba(20,20,45,0.96); border: 1px solid rgba(255,255,255,0.15); border-radius: 10px; padding: 6px 0; z-index: 200; min-width: 170px; backdrop-filter: blur(12px); box-shadow: 0 8px 30px rgba(0,0,0,0.5); }
.arrow-ctx-menu.show { display: block; }
.ctx-width-grid { display: flex; align-items: center; gap: 8px; padding: 6px 18px 8px; }
.width-opt { cursor: pointer; border: 2px solid transparent; border-radius: 6px; padding: 4px 8px; transition: border-color 0.15s; display: flex; align-items: center; }
.width-opt:hover { border-color: rgba(255,255,255,0.5); }
.width-opt.active { border-color: #fff; }
.top-bar { position: fixed; top: 0; right: 0; display: flex; align-items: center; gap: 12px; padding: 10px 16px; z-index: 10; background: rgba(20,20,50,0.92); border-bottom-left-radius: 10px; backdrop-filter: blur(8px); }
.top-bar-name { color: rgba(255,255,255,0.9); font-size: 14px; font-weight: 600; cursor: pointer; padding: 6px 14px; border-radius: 8px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.15); transition: background 0.2s; max-width: 240px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.top-bar-name:hover { background: rgba(255,255,255,0.2); }
.top-bar-btn { color: #ddd; font-size: 13px; font-weight: 600; cursor: pointer; padding: 6px 14px; border-radius: 8px; background: rgba(255,255,255,0.12); border: 1px solid rgba(255,255,255,0.15); transition: background 0.2s; white-space: nowrap; }
.top-bar-btn:hover { background: rgba(255,255,255,0.25); color: #fff; }
.name-edit-input { position: fixed; border: 2px solid #5bf; border-radius: 8px; background: rgba(30,30,60,0.95); color: #fff; font-size: 14px; font-weight: 600; outline: none; z-index: 300; padding: 6px 14px; }
</style>
</head>
<body>

<div class="top-bar">
  <div id="pageName" class="top-bar-name" title="クリックで名前変更">SPA</div>
  <div id="newPageBtn" class="top-bar-btn">+ New Page</div>
</div>
<div id="ctx-menu" class="ctx-menu">
  <div class="ctx-item" data-action="add">+ 子ノードを追加</div>
  <div class="ctx-item" data-action="align">⊞ 子ノードを整列</div>
  <div class="ctx-item" data-action="align-left">↕ 縦列を左揃え</div>
  <div class="ctx-color-label">このノードの色</div>
  <div class="ctx-color-grid" id="ctx-colors-single"></div>
  <div class="ctx-color-label" id="ctx-color-all-label">子ノードも含めて色変更</div>
  <div class="ctx-color-grid" id="ctx-colors-all"></div>
  <div class="ctx-sep"></div>
  <div class="ctx-item" data-action="toggle" id="ctx-toggle">折りたたむ</div>
  <div class="ctx-sep"></div>
  <div class="ctx-item" data-action="equalize-width" id="ctx-eq-w">↔ 幅を揃える</div>
  <div class="ctx-sep"></div>
  <div class="ctx-item" data-action="delete" style="color:#e55;">削除</div>
  <div class="ctx-item" data-action="delete-selected" id="ctx-del-sel" style="color:#e55;">選択ノードを削除</div>
</div>
<div id="arrow-ctx-menu" class="arrow-ctx-menu">
  <div class="ctx-color-label">線の太さ</div>
  <div class="ctx-width-grid" id="arrow-ctx-widths"></div>
  <div class="ctx-color-label">矢印の色</div>
  <div class="ctx-color-grid" id="arrow-ctx-colors"></div>
  <div class="ctx-sep"></div>
  <div class="ctx-item" data-action="arrow-delete" style="color:#e55;">矢印を削除</div>
</div>
<div class="controls">
  <button id="arrowMode" title="矢印モード"><svg width="20" height="20" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><line x1="3" y1="17" x2="15" y2="5"/><polyline points="9,4 16,4 16,11"/></svg></button>
  <button id="zoomIn" title="ズームイン">+</button>
  <button id="zoomOut" title="ズームアウト">−</button>
  <button id="autoFormat" title="自動整列">⊞</button>
  <button id="resetView" title="リセット">⌂</button>
</div>

<div id="container">
  <svg id="mindmap">
    <defs>
      <filter id="glow">
        <feGaussianBlur stdDeviation="3" result="blur"/>
        <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
      </filter>
    </defs>
    <g id="viewport">
      <g id="lines"></g>
      <g id="free-arrows"></g>
      <g id="anchors"></g>
      <g id="nodes"></g>
      <rect id="select-box" x="0" y="0" width="0" height="0" visibility="hidden"/>
    </g>
  </svg>
</div>

<script>
const DATA = {
  text: 'SPA',
  color: '#e94560',
  children: [
    {
      text: 'SPA開設', color: '#4a90d9',
      children: [
        { text: 'Advertisement', color: '#4a90d9', children: [] },
        { text: 'セミナー', color: '#4a90d9', children: [] },
        { text: 'クロージング', color: '#4a90d9', children: [] },
      ]
    },
    {
      text: '教育', color: '#4a90d9',
      children: [
        { text: 'UTAGE', color: '#4a90d9', children: [] },
        { text: 'UTAGE自動配信', color: '#4a90d9', children: [] },
        { text: '教材全て完了', color: '#4a90d9', children: [] },
      ]
    },
    { text: '会員ページ', color: '#4a90d9', children: [] },
    { text: 'ZOOM面談', color: '#4a90d9', children: [] },
    {
      text: '最終チェック', color: '#4a90d9',
      children: [
        { text: 'デビュー', color: '#4a90d9', children: [] },
      ]
    },
  ]
};

const DEFAULT_TREE = JSON.parse(JSON.stringify(DATA)); // deep copy for reset

// State
const collapsed = new Set();
const customPos = new Map();
const customWidth = new Map();
const anchorOverrides = new Map();
let nodeIdCounter = 0;
const nodeMap = new Map();
let dropTargetId = null;
let lastNodeBoxes = [];
let pendingEditNodeId = null;
const selectedNodes = new Set();
let viewX = 0, viewY = 0, scale = 1;

// Free arrow state
let freeArrows = [];
let freeArrowIdCounter = 0;
let isArrowMode = false;
let selectedArrowId = null;
let arrowDrawColor = '#5bf';

// Assign IDs
function assignIds(node) {
  node.id = nodeIdCounter++;
  nodeMap.set(node.id, node);
  if (node.children) node.children.forEach(assignIds);
}

// Serialize tree for saving
function serializeTree(node) {
  return { id: node.id, text: node.text, color: node.color,
    children: (node.children || []).map(serializeTree) };
}

function rebuildNode(saved) {
  const node = { id: saved.id, text: saved.text, color: saved.color,
    children: (saved.children || []).map(rebuildNode) };
  nodeMap.set(node.id, node);
  if (node.id >= nodeIdCounter) nodeIdCounter = node.id + 1;
  return node;
}

// Undo history
const undoStack = [];
const MAX_UNDO = 50;

function snapshotState() {
  return JSON.stringify({
    tree: serializeTree(DATA),
    customPos: Object.fromEntries(customPos),
    customWidth: Object.fromEntries(customWidth),
    collapsed: [...collapsed],
    anchors: Object.fromEntries(anchorOverrides),
    freeArrows: freeArrows.map(a => ({...a})),
    freeArrowIdCounter,
  });
}

function pushUndo() {
  const snap = snapshotState();
  if (undoStack.length && undoStack[undoStack.length - 1] === snap) return;
  undoStack.push(snap);
  if (undoStack.length > MAX_UNDO) undoStack.shift();
}

function undo() {
  if (!undoStack.length) return;
  const snap = JSON.parse(undoStack.pop());
  // Restore tree
  nodeIdCounter = 0; nodeMap.clear();
  const tree = snap.tree;
  DATA.id = tree.id; DATA.text = tree.text; DATA.color = tree.color;
  DATA.children = (tree.children || []).map(rebuildNode);
  nodeMap.set(DATA.id, DATA);
  if (DATA.id >= nodeIdCounter) nodeIdCounter = DATA.id + 1;
  // Restore maps
  customPos.clear();
  for (const [k, v] of Object.entries(snap.customPos || {})) customPos.set(Number(k), v);
  customWidth.clear();
  for (const [k, v] of Object.entries(snap.customWidth || {})) customWidth.set(Number(k), v);
  collapsed.clear();
  for (const id of (snap.collapsed || [])) collapsed.add(id);
  anchorOverrides.clear();
  for (const [k, v] of Object.entries(snap.anchors || {})) anchorOverrides.set(k, v);
  freeArrows = (snap.freeArrows || []).map(a => ({...a}));
  freeArrowIdCounter = snap.freeArrowIdCounter || 0;
  selectedArrowId = null;
  selectedNodes.clear();
  render();
  updateTransform();
}

// Auto-save to localStorage
function saveState() {
  try {
    // Save ALL nodes' displayed positions, not just customPos entries
    // This ensures positions are stable across reloads
    const allPos = {};
    nodeMap.forEach((node, id) => {
      if (node._x !== undefined && node._y !== undefined) {
        allPos[id] = { x: node._x, y: node._y };
      }
    });
    const state = {
      tree: serializeTree(DATA),
      customPos: allPos,
      customWidth: Object.fromEntries(customWidth),
      collapsed: [...collapsed],
      anchors: Object.fromEntries(anchorOverrides),
      freeArrows: freeArrows.map(a => ({...a})),
      freeArrowIdCounter,
      viewX, viewY, scale,
    };
    localStorage.setItem('mindmap', JSON.stringify(state));
  } catch (e) {}
}

// Load from localStorage
function loadState() {
  try {
    const raw = localStorage.getItem('mindmap');
    if (!raw) return false;
    const s = JSON.parse(raw);
    // Restore tree
    nodeIdCounter = 0; nodeMap.clear();
    const tree = s.tree;
    DATA.id = tree.id; DATA.text = tree.text; DATA.color = tree.color;
    DATA.children = (tree.children || []).map(rebuildNode);
    nodeMap.set(DATA.id, DATA);
    if (DATA.id >= nodeIdCounter) nodeIdCounter = DATA.id + 1;
    // Restore maps
    customPos.clear();
    for (const [k, v] of Object.entries(s.customPos || {})) customPos.set(Number(k), v);
    customWidth.clear();
    for (const [k, v] of Object.entries(s.customWidth || {})) customWidth.set(Number(k), v);
    collapsed.clear();
    for (const id of (s.collapsed || [])) collapsed.add(id);
    anchorOverrides.clear();
    for (const [k, v] of Object.entries(s.anchors || {})) anchorOverrides.set(k, v);
    freeArrows = (s.freeArrows || []).map(a => ({...a}));
    freeArrowIdCounter = s.freeArrowIdCounter || 0;
    viewX = s.viewX || 0; viewY = s.viewY || 0; scale = s.scale || 1;
    return true;
  } catch (e) { return false; }
}

// Reset to default tree
function resetAll() {
  const def = JSON.parse(JSON.stringify(DEFAULT_TREE));
  nodeIdCounter = 0; nodeMap.clear();
  DATA.text = def.text; DATA.color = def.color; DATA.children = def.children;
  assignIds(DATA);
  customPos.clear(); customWidth.clear(); anchorOverrides.clear();
  collapsed.clear(); selectedNodes.clear();
  freeArrows = []; freeArrowIdCounter = 0; selectedArrowId = null;
  viewX = 0; viewY = 0; scale = 1;
  localStorage.removeItem('mindmap');
}

// Init: ?reset parameter clears corrupted state
if (new URLSearchParams(window.location.search).has('reset')) {
  localStorage.removeItem('mindmap');
  localStorage.removeItem('mindmap_name');
  window.history.replaceState({}, '', window.location.pathname);
}
// Migration: force reload from default DATA (v2 = SPA tree)
if (localStorage.getItem('mindmap_version') !== 'v4') {
  localStorage.removeItem('mindmap');
  localStorage.removeItem('mindmap_name');
  localStorage.setItem('mindmap_version', 'v4');
}
// Init: load saved state or assign fresh IDs
const isFirstLoad = !loadState();
if (isFirstLoad) { assignIds(DATA); }

// Layout
function computeLayout(node, depth, angleStart, angleEnd, parentX, parentY, pNode) {
  const items = [];
  if (depth === 0) {
    const pos = customPos.get(node.id);
    const x = pos ? pos.x : 0;
    const y = pos ? pos.y : 0;
    node._x = x;
    node._y = y;
    items.push({ node, x, y, depth, parentNode: null });
    if (!collapsed.has(node.id) && node.children.length) {
      const step = (angleEnd - angleStart) / node.children.length;
      node.children.forEach((child, i) => {
        const a0 = angleStart + step * i;
        const a1 = a0 + step;
        items.push(...computeLayout(child, 1, a0, a1, x, y, node));
      });
    }
  } else {
    const angleMid = (angleStart + angleEnd) / 2;
    const dist = depth === 1 ? 220 : 140 + depth * 20;
    let x, y;
    const pos = customPos.get(node.id);
    if (pos) {
      x = pos.x;
      y = pos.y;
    } else {
      x = parentX + Math.cos(angleMid) * dist;
      y = parentY + Math.sin(angleMid) * dist;
    }
    node._x = x;
    node._y = y;
    items.push({ node, x, y, depth, parentX, parentY, parentNode: pNode });
    if (!collapsed.has(node.id) && node.children && node.children.length) {
      const spread = Math.min((angleEnd - angleStart), Math.PI * 0.6);
      const mid = angleMid;
      const cStart = mid - spread / 2;
      const step = node.children.length > 1 ? spread / (node.children.length - 1) : 0;
      node.children.forEach((child, i) => {
        const a = node.children.length > 1 ? cStart + step * i : mid;
        const halfStep = spread / node.children.length / 2;
        items.push(...computeLayout(child, depth + 1, a - halfStep, a + halfStep, x, y, node));
      });
    }
  }
  return items;
}

// Line-rect intersection (Liang-Barsky), ignoring near-endpoints
function segHitsRect(x1, y1, x2, y2, l, t, r, b) {
  const dx = x2 - x1, dy = y2 - y1;
  const p = [-dx, dx, -dy, dy];
  const q = [x1 - l, r - x1, y1 - t, b - y1];
  let u1 = 0, u2 = 1;
  for (let i = 0; i < 4; i++) {
    if (p[i] === 0) { if (q[i] < 0) return false; }
    else {
      const u = q[i] / p[i];
      if (p[i] < 0) u1 = Math.max(u1, u);
      else u2 = Math.min(u2, u);
      if (u1 > u2) return false;
    }
  }
  return u1 < 0.92 && u2 > 0.08;
}

// Get node width for a given item
function nodeWidth(node, depth) {
  if (customWidth.has(node.id)) return customWidth.get(node.id);
  const tl = node.text.length;
  return depth === 0 ? Math.max(180, tl * 18 + 40) : Math.max(100, tl * 14 + 30);
}

// Tree manipulation
function findParent(target, tree) {
  if (tree.children) {
    for (const child of tree.children) {
      if (child.id === target.id) return tree;
      const found = findParent(target, child);
      if (found) return found;
    }
  }
  return null;
}

function isDescendantOf(ancestor, node) {
  if (!ancestor.children) return false;
  for (const child of ancestor.children) {
    if (child.id === node.id) return true;
    if (isDescendantOf(child, node)) return true;
  }
  return false;
}

function reparentNode(node, newParent) {
  pushUndo();
  const oldParent = findParent(node, DATA);
  if (!oldParent || oldParent.id === newParent.id) return;
  // Remove from old parent
  oldParent.children = oldParent.children.filter(c => c.id !== node.id);
  // Add to new parent
  if (!newParent.children) newParent.children = [];
  newParent.children.push(node);
  // Update color to match new branch
  function setColor(n, color) { n.color = color; if (n.children) n.children.forEach(c => setColor(c, color)); }
  setColor(node, newParent.color);
  // Clean up old anchor overrides
  const oldKey = `${oldParent.id}-${node.id}`;
  anchorOverrides.delete(oldKey);
  // Clear custom position so it gets a fresh layout position
  customPos.delete(node.id);
}

function addChildNode(parentNode) {
  pushUndo();
  const newNode = {
    text: '新規',
    color: parentNode.color,
    children: [],
    id: nodeIdCounter++,
  };
  nodeMap.set(newNode.id, newNode);
  if (!parentNode.children) parentNode.children = [];
  parentNode.children.push(newNode);
  collapsed.delete(parentNode.id);
  return newNode;
}

function getNodeDepth(node) {
  let depth = 0, cur = node;
  while (true) {
    const p = findParent(cur, DATA);
    if (!p) break;
    depth++;
    cur = p;
  }
  return depth;
}

// Default node width from text length (without customWidth)
function defaultNodeWidth(node, depth) {
  const tl = node.text.length;
  return depth === 0 ? Math.max(180, tl * 18 + 40) : Math.max(100, tl * 14 + 30);
}

// Auto-format: clean left-to-right tree layout
function autoFormat() {
  pushUndo();
  customPos.clear();
  customWidth.clear();
  anchorOverrides.clear();
  autoFormatFrom(DATA, 0, 0, 0);
  render();
  updateTransform();
}

function autoFormatFrom(root, startDepth, startX, startY) {
  const GAP = 20;
  const NODE_H = 38;
  const ROOT_H = 56;

  // Detect if children are laid out horizontally or vertically
  // by checking how consecutive siblings are arranged relative to each other
  function detectDir(node) {
    if (!node.children || node.children.length < 2) return 'h';
    let sumDx = 0, sumDy = 0;
    for (let i = 1; i < node.children.length; i++) {
      const prev = node.children[i - 1];
      const curr = node.children[i];
      sumDx += Math.abs((curr._x || 0) - (prev._x || 0));
      sumDy += Math.abs((curr._y || 0) - (prev._y || 0));
    }
    return sumDy > sumDx ? 'v' : 'h';
  }

  // Collect max width per group of siblings sharing same direction & depth
  function getNodeH(node, depth) { return depth === 0 ? ROOT_H : NODE_H; }

  // Compute subtree size along the stacking axis
  function subtreeSize(node, depth, dir) {
    const nw = defaultNodeWidth(node, depth);
    const nh = getNodeH(node, depth);
    const primary = dir === 'h' ? nh : nw; // size along stacking axis
    if (collapsed.has(node.id) || !node.children || !node.children.length) return primary;
    const childDir = detectDir(node);
    if (childDir === dir) {
      // Children stack along same axis — sum them
      let total = 0;
      for (const c of node.children) total += subtreeSize(c, depth + 1, childDir);
      total += (node.children.length - 1) * GAP;
      return Math.max(primary, total);
    } else {
      // Children go perpendicular — max of them
      let maxS = 0;
      for (const c of node.children) maxS = Math.max(maxS, subtreeSize(c, depth + 1, childDir));
      return Math.max(primary, maxS);
    }
  }

  // Equalize widths among siblings
  function equalizeSiblingWidths(node, depth) {
    if (collapsed.has(node.id) || !node.children || !node.children.length) return;
    let maxW = 0;
    for (const c of node.children) {
      maxW = Math.max(maxW, defaultNodeWidth(c, depth + 1));
    }
    for (const c of node.children) {
      customWidth.set(c.id, maxW);
    }
    for (const c of node.children) equalizeSiblingWidths(c, depth + 1);
  }

  // Recursive layout
  function layout(node, depth, x, y) {
    customPos.set(node.id, { x, y });
    if (!customWidth.has(node.id)) {
      customWidth.set(node.id, defaultNodeWidth(node, depth));
    }

    if (collapsed.has(node.id) || !node.children || !node.children.length) return;

    const dir = detectDir(node);
    const nw = customWidth.get(node.id) || defaultNodeWidth(node, depth);
    const nh = getNodeH(node, depth);

    if (dir === 'h') {
      // Children go to the right, stacked vertically
      let maxChildW = 0;
      for (const c of node.children) {
        maxChildW = Math.max(maxChildW, customWidth.get(c.id) || defaultNodeWidth(c, depth + 1));
      }
      const nextX = x + nw / 2 + GAP + maxChildW / 2;
      const childSizes = node.children.map(c => subtreeSize(c, depth + 1, 'v'));
      const totalH = childSizes.reduce((a, b) => a + b, 0) + (node.children.length - 1) * GAP;
      let curY = y - totalH / 2;
      for (let i = 0; i < node.children.length; i++) {
        const cs = childSizes[i];
        layout(node.children[i], depth + 1, nextX, curY + cs / 2);
        curY += cs + GAP;
      }
    } else {
      // Children go downward, stacked vertically at same X
      const childH = NODE_H;
      let curY = y + nh / 2 + GAP + childH / 2;
      for (let i = 0; i < node.children.length; i++) {
        layout(node.children[i], depth + 1, x, curY);
        curY += childH + GAP;
      }
    }
  }

  equalizeSiblingWidths(root, startDepth);
  if (!customWidth.has(root.id)) {
    customWidth.set(root.id, defaultNodeWidth(root, startDepth));
  }
  layout(root, startDepth, startX, startY);
}

// Auto-format subtree only (keep root position, format children)
function autoFormatSubtree(parentNode) {
  if (!parentNode.children || parentNode.children.length === 0) return;
  pushUndo();
  const depth = getNodeDepth(parentNode);
  // Clear custom data for all descendants
  function clearDescendants(node) {
    if (!node.children) return;
    for (const c of node.children) {
      customPos.delete(c.id);
      customWidth.delete(c.id);
      clearDescendants(c);
    }
  }
  clearDescendants(parentNode);
  // Re-format from this node keeping its position
  autoFormatFrom(parentNode, depth, parentNode._x || 0, parentNode._y || 0);
  anchorOverrides.clear();
  render();
  updateTransform();
}

// Align selected nodes in a vertical column, left-aligned
// Only moves selected nodes; all others stay in place
function alignSelectedLeft() {
  if (selectedNodes.size < 2) return;
  pushUndo();
  const GAP = 20;
  const nodeH = 38;

  // Lock ALL non-selected node positions into customPos
  // so resolveOverlaps treats them as fixed and never moves them
  const savedPositions = new Map();
  nodeMap.forEach((n, id) => {
    if (!selectedNodes.has(id) && n._x !== undefined && n._y !== undefined) {
      const pos = { x: n._x, y: n._y };
      customPos.set(id, pos);
      savedPositions.set(id, pos);
    }
  });

  // Collect selected nodes with their current positions
  const targets = [];
  for (const nid of selectedNodes) {
    const n = nodeMap.get(nid);
    if (!n) continue;
    const d = getNodeDepth(n);
    const w = customWidth.has(nid) ? customWidth.get(nid) : nodeWidth(n, d);
    targets.push({ node: n, id: nid, x: n._x || 0, y: n._y || 0, w, depth: d });
  }

  // Sort by current Y position (top to bottom)
  targets.sort((a, b) => a.y - b.y);

  // Equalize widths
  let maxW = 0;
  for (const t of targets) maxW = Math.max(maxW, t.w);
  for (const t of targets) customWidth.set(t.id, maxW);

  // Find the leftmost left-edge as the alignment reference
  let minLeftEdge = Infinity;
  for (const t of targets) {
    const leftEdge = t.x - t.w / 2;
    if (leftEdge < minLeftEdge) minLeftEdge = leftEdge;
  }
  const centerX = minLeftEdge + maxW / 2;

  // Only change X to align left edges; keep original Y positions
  for (const t of targets) {
    customPos.set(t.id, { x: centerX, y: t.y });
    t.node._x = centerX;
  }

  render();

  // Force restore non-selected node positions after render
  // (in case resolveOverlaps still moved them)
  let needRerender = false;
  for (const [id, pos] of savedPositions) {
    const n = nodeMap.get(id);
    if (n && (Math.abs(n._x - pos.x) > 0.1 || Math.abs(n._y - pos.y) > 0.1)) {
      customPos.set(id, pos);
      n._x = pos.x;
      n._y = pos.y;
      needRerender = true;
    }
  }
  if (needRerender) render();

  updateTransform();
}

// Anchor utilities
function autoSide(fromX, fromY, toX, toY) {
  const a = Math.atan2(toY - fromY, toX - fromX);
  if (a >= -Math.PI / 4 && a < Math.PI / 4) return 'right';
  if (a >= Math.PI / 4 && a < 3 * Math.PI / 4) return 'bottom';
  if (a >= -3 * Math.PI / 4 && a < -Math.PI / 4) return 'top';
  return 'left';
}

function anchorPos(cx, cy, w, h, side) {
  switch (side) {
    case 'top': return { x: cx, y: cy - h / 2 };
    case 'bottom': return { x: cx, y: cy + h / 2 };
    case 'left': return { x: cx - w / 2, y: cy };
    case 'right': return { x: cx + w / 2, y: cy };
  }
}

function nearestSide(nx, ny, w, h, mx, my) {
  const sides = {
    top: { x: nx, y: ny - h / 2 },
    bottom: { x: nx, y: ny + h / 2 },
    left: { x: nx - w / 2, y: ny },
    right: { x: nx + w / 2, y: ny },
  };
  let best = 'right', bestD = Infinity;
  for (const [s, p] of Object.entries(sides)) {
    const d = Math.hypot(mx - p.x, my - p.y);
    if (d < bestD) { bestD = d; best = s; }
  }
  return best;
}

// Render
const svgNS = 'http://www.w3.org/2000/svg';
const linesGroup = document.getElementById('lines');
const freeArrowsGroup = document.getElementById('free-arrows');
const anchorsGroup = document.getElementById('anchors');
const nodesGroup = document.getElementById('nodes');
const svgDefs = document.querySelector('#mindmap defs');

// Arrow marker cache
const arrowMarkerCache = new Map();

function getArrowMarker(color) {
  const key = color.replace('#', '');
  if (arrowMarkerCache.has(key)) return `url(#arrow-${key})`;
  const marker = document.createElementNS(svgNS, 'marker');
  marker.setAttribute('id', `arrow-${key}`);
  marker.setAttribute('viewBox', '0 0 10 10');
  marker.setAttribute('refX', '9');
  marker.setAttribute('refY', '5');
  marker.setAttribute('markerWidth', '8');
  marker.setAttribute('markerHeight', '8');
  marker.setAttribute('orient', 'auto-start-reverse');
  const poly = document.createElementNS(svgNS, 'polygon');
  poly.setAttribute('points', '0,1 10,5 0,9');
  poly.setAttribute('fill', color);
  marker.appendChild(poly);
  svgDefs.appendChild(marker);
  arrowMarkerCache.set(key, true);
  return `url(#arrow-${key})`;
}

function renderFreeArrows() {
  freeArrowsGroup.innerHTML = '';
  for (const arrow of freeArrows) {
    const { id, x1, y1, x2, y2, cx, cy, color } = arrow;
    const markerUrl = getArrowMarker(color);
    const d = `M${x1},${y1} Q${cx},${cy} ${x2},${y2}`;

    // Hit area (invisible, wider for easier clicking)
    const hit = document.createElementNS(svgNS, 'path');
    hit.setAttribute('d', d);
    hit.setAttribute('class', 'free-arrow-hit');
    hit.dataset.arrowId = id;
    freeArrowsGroup.appendChild(hit);

    // Visible path
    const path = document.createElementNS(svgNS, 'path');
    path.setAttribute('d', d);
    path.setAttribute('class', 'free-arrow-path');
    path.setAttribute('stroke', color);
    const sw = arrow.strokeWidth || 4;
    path.setAttribute('stroke-width', selectedArrowId === id ? sw + 1 : sw);
    path.setAttribute('marker-end', markerUrl);
    if (selectedArrowId === id) {
      path.setAttribute('stroke-dasharray', '8 4');
    }
    path.dataset.arrowId = id;
    freeArrowsGroup.appendChild(path);

    // Selection handles (only when selected)
    if (selectedArrowId === id) {
      // Start point handle
      const h1 = document.createElementNS(svgNS, 'circle');
      h1.setAttribute('cx', x1); h1.setAttribute('cy', y1);
      h1.setAttribute('r', 6); h1.setAttribute('fill', color);
      h1.setAttribute('stroke', '#fff'); h1.setAttribute('stroke-width', 2);
      h1.setAttribute('class', 'free-arrow-handle');
      h1.dataset.handleType = 'start';
      h1.dataset.arrowId = id;
      freeArrowsGroup.appendChild(h1);

      // End point handle
      const h2 = document.createElementNS(svgNS, 'circle');
      h2.setAttribute('cx', x2); h2.setAttribute('cy', y2);
      h2.setAttribute('r', 6); h2.setAttribute('fill', color);
      h2.setAttribute('stroke', '#fff'); h2.setAttribute('stroke-width', 2);
      h2.setAttribute('class', 'free-arrow-handle');
      h2.dataset.handleType = 'end';
      h2.dataset.arrowId = id;
      freeArrowsGroup.appendChild(h2);

      // Control point handle (diamond shape)
      const cp = document.createElementNS(svgNS, 'rect');
      cp.setAttribute('x', cx - 5); cp.setAttribute('y', cy - 5);
      cp.setAttribute('width', 10); cp.setAttribute('height', 10);
      cp.setAttribute('transform', `rotate(45,${cx},${cy})`);
      cp.setAttribute('fill', color); cp.setAttribute('stroke', '#fff');
      cp.setAttribute('stroke-width', 2);
      cp.setAttribute('class', 'free-arrow-handle');
      cp.dataset.handleType = 'control';
      cp.dataset.arrowId = id;
      freeArrowsGroup.appendChild(cp);

      // Line from start to control point (guide line)
      const guide1 = document.createElementNS(svgNS, 'line');
      guide1.setAttribute('x1', x1); guide1.setAttribute('y1', y1);
      guide1.setAttribute('x2', cx); guide1.setAttribute('y2', cy);
      guide1.setAttribute('stroke', 'rgba(255,255,255,0.2)');
      guide1.setAttribute('stroke-width', 1);
      guide1.setAttribute('stroke-dasharray', '3 3');
      freeArrowsGroup.insertBefore(guide1, h1);

      // Line from control to end point (guide line)
      const guide2 = document.createElementNS(svgNS, 'line');
      guide2.setAttribute('x1', cx); guide2.setAttribute('y1', cy);
      guide2.setAttribute('x2', x2); guide2.setAttribute('y2', y2);
      guide2.setAttribute('stroke', 'rgba(255,255,255,0.2)');
      guide2.setAttribute('stroke-width', 1);
      guide2.setAttribute('stroke-dasharray', '3 3');
      freeArrowsGroup.insertBefore(guide2, h1);
    }
  }
}

// Resolve node overlaps after layout
function resolveOverlaps(items) {
  const gap = 18;
  const movedNodes = new Set();
  for (let iter = 0; iter < 20; iter++) {
    let moved = false;
    for (let i = 0; i < items.length; i++) {
      if (items[i].depth === 0) continue;
      for (let j = i + 1; j < items.length; j++) {
        if (items[j].depth === 0) continue;
        const a = items[i], b = items[j];
        const aFixed = customPos.has(a.node.id);
        const bFixed = customPos.has(b.node.id);
        if (aFixed && bFixed) continue; // both user-positioned, never touch
        const aw = nodeWidth(a.node, a.depth);
        const ah = a.depth === 0 ? 56 : 38;
        const bw = nodeWidth(b.node, b.depth);
        const bh = b.depth === 0 ? 56 : 38;
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const ox = (aw + bw) / 2 + gap - Math.abs(dx);
        const oy = (ah + bh) / 2 + gap - Math.abs(dy);
        if (ox > 0 && oy > 0) {
          moved = true;
          let ra = 0.5, rb = 0.5;
          if (aFixed && !bFixed) { ra = 0; rb = 1; }
          else if (bFixed && !aFixed) { ra = 1; rb = 0; }
          if (ox < oy) {
            const p = ox + 0.5;
            if (dx >= 0) { a.x -= p * ra; b.x += p * rb; }
            else { a.x += p * ra; b.x -= p * rb; }
          } else {
            const p = oy + 0.5;
            if (dy >= 0) { a.y -= p * ra; b.y += p * rb; }
            else { a.y += p * ra; b.y -= p * rb; }
          }
          a.node._x = a.x; b.node._x = b.x;
          a.node._y = a.y; b.node._y = b.y;
          if (ra > 0) movedNodes.add(a.node.id);
          if (rb > 0) movedNodes.add(b.node.id);
        }
      }
    }
    if (!moved) break;
  }
  // Save only nodes that were moved by overlap resolution (stabilize on reload)
  for (const it of items) {
    if (movedNodes.has(it.node.id)) {
      customPos.set(it.node.id, { x: it.x, y: it.y });
    }
  }
  // Update parent references
  const posMap = new Map(items.map(it => [it.node.id, { x: it.x, y: it.y }]));
  for (const item of items) {
    if (item.parentNode) {
      const pp = posMap.get(item.parentNode.id);
      if (pp) { item.parentX = pp.x; item.parentY = pp.y; }
    }
  }
}

function render() {
  const items = computeLayout(DATA, 0, -Math.PI, Math.PI, 0, 0);
  resolveOverlaps(items);
  // Stabilize: register all rendered positions in customPos
  // so that on reload ALL nodes are treated as fixed by resolveOverlaps
  for (const it of items) {
    if (!customPos.has(it.node.id)) {
      customPos.set(it.node.id, { x: it.x, y: it.y });
    }
  }
  linesGroup.innerHTML = '';
  anchorsGroup.innerHTML = '';
  nodesGroup.innerHTML = '';

  // Build node boxes for collision detection & anchor lookup
  const nodeBoxes = items.map(it => {
    const w = nodeWidth(it.node, it.depth);
    const h = it.depth === 0 ? 56 : 38;
    return { id: it.node.id, x: it.x, y: it.y, w, h, depth: it.depth };
  });
  const boxById = new Map(nodeBoxes.map(b => [b.id, b]));
  lastNodeBoxes = nodeBoxes;

  // Draw lines with anchors
  items.forEach(({ node, x, y, depth, parentX, parentY, parentNode }) => {
    if (depth === 0) return;
    const pid = parentNode ? parentNode.id : -1;
    const key = `${pid}-${node.id}`;
    const pBox = boxById.get(pid);
    const cBox = boxById.get(node.id);
    if (!pBox || !cBox) return;

    // Determine anchor sides
    const override = anchorOverrides.get(key);
    const fromSide = override ? override.from : autoSide(pBox.x, pBox.y, cBox.x, cBox.y);
    const toSide = override ? override.to : autoSide(cBox.x, cBox.y, pBox.x, pBox.y);
    const fp = anchorPos(pBox.x, pBox.y, pBox.w, pBox.h, fromSide);
    const tp = anchorPos(cBox.x, cBox.y, cBox.w, cBox.h, toSide);

    // Collision detection on anchor-to-anchor line
    const pad = 6;
    const hits = [];
    for (const box of nodeBoxes) {
      if (box.id === node.id || box.id === pid) continue;
      if (segHitsRect(fp.x, fp.y, tp.x, tp.y,
          box.x - box.w / 2 - pad, box.y - box.h / 2 - pad,
          box.x + box.w / 2 + pad, box.y + box.h / 2 + pad)) {
        hits.push(box);
      }
    }

    const path = document.createElementNS(svgNS, 'path');
    let d;

    if (hits.length > 0) {
      const dx = tp.x - fp.x, dy = tp.y - fp.y;
      const len = Math.hypot(dx, dy) || 1;
      let px = -dy / len, py = dx / len;
      let sumPerp = 0;
      for (const box of hits) {
        sumPerp += (box.x - fp.x) * px + (box.y - fp.y) * py;
      }
      if (sumPerp > 0) { px = -px; py = -py; }
      let needBow = 0;
      for (const box of hits) {
        const cd = -((box.x - fp.x) * px + (box.y - fp.y) * py);
        needBow = Math.max(needBow, cd + Math.max(box.w / 2, box.h / 2) + pad);
      }
      const bow = needBow + 8;
      const mx = fp.x + dx * 0.5 + px * bow;
      const my = fp.y + dy * 0.5 + py * bow;
      d = `M${fp.x},${fp.y} Q${mx},${my} ${tp.x},${tp.y}`;
    } else {
      d = `M${fp.x},${fp.y} L${tp.x},${tp.y}`;
    }

    path.setAttribute('d', d);
    path.setAttribute('class', 'branch-line');
    path.setAttribute('stroke', node.color);
    path.setAttribute('stroke-width', Math.max(2, 4 - depth));
    linesGroup.appendChild(path);

    // Draggable anchor dots (from = parent side, to = child side)
    [{ pos: fp, box: pBox, end: 'from' }, { pos: tp, box: cBox, end: 'to' }].forEach(({ pos, box, end }) => {
      const dot = document.createElementNS(svgNS, 'circle');
      dot.setAttribute('cx', pos.x);
      dot.setAttribute('cy', pos.y);
      dot.setAttribute('r', 6);
      dot.setAttribute('fill', node.color);
      dot.setAttribute('stroke', '#fff');
      dot.setAttribute('stroke-width', 2);
      dot.setAttribute('class', 'anchor-dot');
      dot.addEventListener('mousedown', (e) => {
        e.stopPropagation();
        e.preventDefault();
        dot.style.opacity = '1';
        function onMove(ev) {
          const wcx = window.innerWidth / 2;
          const wcy = window.innerHeight / 2;
          const svgX = (ev.clientX - wcx - viewX) / scale;
          const svgY = (ev.clientY - wcy - viewY) / scale;
          const side = nearestSide(box.x, box.y, box.w, box.h, svgX, svgY);
          const cur = anchorOverrides.get(key) || { from: fromSide, to: toSide };
          if (end === 'from') cur.from = side; else cur.to = side;
          anchorOverrides.set(key, cur);
          render();
          updateTransform();
        }
        function onUp() {
          window.removeEventListener('mousemove', onMove);
          window.removeEventListener('mouseup', onUp);
        }
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);
      });
      anchorsGroup.appendChild(dot);
    });
  });

  // Draw nodes
  items.forEach(({ node, x, y, depth }) => {
    const g = document.createElementNS(svgNS, 'g');
    g.setAttribute('class', 'node-group');
    g.setAttribute('transform', `translate(${x},${y})`);

    const isRoot = depth === 0;
    const hasChildren = node.children && node.children.length > 0;
    const isCollapsed = collapsed.has(node.id);

    // Size
    const textLen = node.text.length;
    const autoW = isRoot ? Math.max(180, textLen * 18 + 40) : Math.max(100, textLen * 14 + 30);
    const w = customWidth.has(node.id) ? customWidth.get(node.id) : autoW;
    const h = isRoot ? 56 : 38;
    const fontSize = isRoot ? 18 : 14;

    // Rect
    const rect = document.createElementNS(svgNS, 'rect');
    rect.setAttribute('x', -w / 2);
    rect.setAttribute('y', -h / 2);
    rect.setAttribute('width', w);
    rect.setAttribute('height', h);
    rect.setAttribute('class', 'node-rect');
    rect.setAttribute('fill', node.color);
    rect.setAttribute('stroke', isRoot ? '#fff' : adjustColor(node.color, 30));
    if (isRoot) rect.setAttribute('filter', 'url(#glow)');
    if (node.id === dropTargetId) rect.classList.add('drop-target');
    if (selectedNodes.has(node.id)) rect.classList.add('selected');
    g.appendChild(rect);

    // Text
    const text = document.createElementNS(svgNS, 'text');
    text.setAttribute('class', 'node-text');
    text.setAttribute('font-size', fontSize);
    text.textContent = node.text;
    g.appendChild(text);

    // Resize handles (left & right edges)
    ['left', 'right'].forEach(side => {
      const rh = document.createElementNS(svgNS, 'rect');
      rh.setAttribute('x', side === 'right' ? w / 2 - 5 : -w / 2 - 5);
      rh.setAttribute('y', -h / 2);
      rh.setAttribute('width', 10);
      rh.setAttribute('height', h);
      rh.setAttribute('rx', 3);
      rh.setAttribute('class', 'resize-handle');
      rh.setAttribute('fill', 'rgba(255,255,255,0.5)');
      rh.addEventListener('mousedown', (e) => {
        e.stopPropagation();
        e.preventDefault();
        pushUndo();
        const startX = e.clientX;
        const origW = w;
        const origNodeX = node._x;
        function onMove(ev) {
          const dx = (ev.clientX - startX) / scale;
          const minW = 60;
          let newW, newX;
          if (side === 'right') {
            newW = Math.max(minW, origW + dx);
            newX = origNodeX + dx / 2;
          } else {
            newW = Math.max(minW, origW - dx);
            newX = origNodeX + dx / 2;
          }
          customWidth.set(node.id, newW);
          customPos.set(node.id, { x: newX, y: node._y });
          render();
          updateTransform();
        }
        function onUp() {
          window.removeEventListener('mousemove', onMove);
          window.removeEventListener('mouseup', onUp);
        }
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);
      });
      g.appendChild(rh);
    });

    // Collapsed badge (small count inside node corner)
    if (hasChildren && isCollapsed) {
      const count = countDescendants(node);
      const bg = document.createElementNS(svgNS, 'g');
      bg.setAttribute('class', 'badge');
      bg.setAttribute('transform', `translate(${w / 2 - 4}, ${-h / 2 + 4})`);
      const br = document.createElementNS(svgNS, 'rect');
      br.setAttribute('x', -12); br.setAttribute('y', -8);
      br.setAttribute('width', 24); br.setAttribute('height', 16);
      br.setAttribute('fill', 'rgba(0,0,0,0.45)');
      bg.appendChild(br);
      const bt = document.createElementNS(svgNS, 'text');
      bt.textContent = '+' + count;
      bg.appendChild(bt);
      g.appendChild(bg);
    }

    // Auto-start edit for newly added node
    if (node.id === pendingEditNodeId) {
      pendingEditNodeId = null;
      requestAnimationFrame(() => startEdit(node, g, w, h, fontSize));
    }

    // Right-click context menu
    g.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      e.stopPropagation();
      showContextMenu(e.clientX, e.clientY, node, g, w, h, fontSize);
    });

    // Drag to move / Click to edit / Shift+Click to select (left button only)
    g.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return; // ignore right-click
      e.stopPropagation();
      e.preventDefault();
      const isShift = e.shiftKey;
      const startMX = e.clientX;
      const startMY = e.clientY;
      let dragged = false;

      // Save undo before drag
      pushUndo();
      // Snapshot original positions of this node + all selected
      const origPositions = new Map();
      const moveSet = new Set(selectedNodes);
      moveSet.add(node.id);
      for (const nid of moveSet) {
        const n = nodeMap.get(nid);
        if (n) origPositions.set(nid, { x: n._x, y: n._y });
      }

      function onMove(ev) {
        const dx = ev.clientX - startMX;
        const dy = ev.clientY - startMY;
        if (!dragged && Math.hypot(dx, dy) < 5) return;
        dragged = true;
        const ddx = dx / scale, ddy = dy / scale;

        if (selectedNodes.has(node.id) && selectedNodes.size > 1) {
          // Move all selected nodes together
          for (const [nid, orig] of origPositions) {
            customPos.set(nid, { x: orig.x + ddx, y: orig.y + ddy });
          }
        } else {
          // Move single node
          const orig = origPositions.get(node.id);
          customPos.set(node.id, { x: orig.x + ddx, y: orig.y + ddy });
        }

        // Detect drop target (only for single node drag without selection)
        dropTargetId = null;
        if (!selectedNodes.has(node.id) || selectedNodes.size <= 1) {
          const svgMX = (ev.clientX - window.innerWidth / 2 - viewX) / scale;
          const svgMY = (ev.clientY - window.innerHeight / 2 - viewY) / scale;
          let bestDist = 40;
          for (const box of lastNodeBoxes) {
            if (box.id === node.id) continue;
            if (box.id === DATA.id) continue;
            const target = nodeMap.get(box.id);
            if (!target) continue;
            if (isDescendantOf(node, target)) continue;
            const dx2 = Math.max(0, Math.abs(svgMX - box.x) - box.w / 2);
            const dy2 = Math.max(0, Math.abs(svgMY - box.y) - box.h / 2);
            const dist = Math.hypot(dx2, dy2);
            if (dist < bestDist) { bestDist = dist; dropTargetId = box.id; }
          }
        }
        render(); updateTransform();
      }

      function onUp() {
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', onUp);
        if (!dragged) {
          if (isShift) {
            // Toggle selection
            if (selectedNodes.has(node.id)) selectedNodes.delete(node.id);
            else selectedNodes.add(node.id);
            render();
          } else {
            selectedNodes.clear();
            startEdit(node, g, w, h, fontSize);
          }
        } else if (dropTargetId !== null) {
          const target = nodeMap.get(dropTargetId);
          if (target) reparentNode(node, target);
          dropTargetId = null;
          render(); updateTransform();
        }
        dropTargetId = null;
      }

      window.addEventListener('mousemove', onMove);
      window.addEventListener('mouseup', onUp);
    });

    nodesGroup.appendChild(g);
  });

  renderFreeArrows();
  saveState();
}

function countDescendants(node) {
  if (!node.children) return 0;
  let count = node.children.length;
  node.children.forEach(c => count += countDescendants(c));
  return count;
}

function adjustColor(hex, amount) {
  const r = Math.min(255, parseInt(hex.slice(1, 3), 16) + amount);
  const g = Math.min(255, parseInt(hex.slice(3, 5), 16) + amount);
  const b = Math.min(255, parseInt(hex.slice(5, 7), 16) + amount);
  return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
}

// Inline Edit
function startEdit(node, g, w, h, fontSize) {
  const bbox = g.getBoundingClientRect();
  const input = document.createElement('input');
  input.type = 'text';
  input.className = 'edit-input';
  input.value = node.text;
  input.style.left = (bbox.left + bbox.width / 2 - w * scale / 2) + 'px';
  input.style.top = (bbox.top + bbox.height / 2 - h * scale / 2) + 'px';
  input.style.width = (w * scale) + 'px';
  input.style.height = (h * scale) + 'px';
  input.style.fontSize = (fontSize * scale) + 'px';
  document.body.appendChild(input);
  input.focus();
  input.select();

  let committed = false;
  function commit() {
    if (committed) return;
    committed = true;
    const val = input.value.trim();
    if (val && val !== node.text) {
      pushUndo();
      node.text = val;
      render();
    }
    if (input.parentNode) input.remove();
  }
  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') { e.preventDefault(); commit(); }
    if (e.key === 'Escape') { committed = true; if (input.parentNode) input.remove(); }
  });
  input.addEventListener('blur', commit);
}

// Context Menu
const ctxMenu = document.getElementById('ctx-menu');
const ctxToggle = document.getElementById('ctx-toggle');
let ctxNode = null, ctxG = null, ctxW = 0, ctxH = 0, ctxFontSize = 0;

const PALETTE = ['#e94560','#f5a623','#7ed321','#4a90d9','#bd10e0','#e05555','#50e3c2','#ff6b81','#ffc048','#45aaf2'];

function applyColorSingle(node, color) {
  pushUndo();
  node.color = color;
  render(); updateTransform();
}

function applyColorAll(node, color) {
  pushUndo();
  function setC(n) { n.color = color; if (n.children) n.children.forEach(setC); }
  setC(node);
  render(); updateTransform();
}

function showContextMenu(mx, my, node, g, w, h, fontSize) {
  ctxNode = node; ctxG = g; ctxW = w; ctxH = h; ctxFontSize = fontSize;
  const hasChildren = node.children && node.children.length > 0;
  const isCollapsed = collapsed.has(node.id);
  ctxToggle.textContent = !hasChildren ? '(子ノードなし)' : isCollapsed ? '展開する' : '折りたたむ';
  ctxToggle.style.opacity = hasChildren ? '1' : '0.4';
  ctxToggle.style.pointerEvents = hasChildren ? 'auto' : 'none';
  const alignItem = ctxMenu.querySelector('[data-action="align"]');
  alignItem.style.display = hasChildren ? '' : 'none';
  const alignLeftItem = ctxMenu.querySelector('[data-action="align-left"]');
  alignLeftItem.style.display = selectedNodes.size >= 2 ? '' : 'none';
  // Single node color palette
  const singleEl = document.getElementById('ctx-colors-single');
  singleEl.innerHTML = '';
  PALETTE.forEach(c => {
    const dot = document.createElement('span');
    dot.className = 'color-dot' + (c === node.color ? ' active' : '');
    dot.style.background = c;
    dot.addEventListener('click', (e) => { e.stopPropagation(); applyColorSingle(node, c); hideContextMenu(); });
    singleEl.appendChild(dot);
  });
  const customS = document.createElement('span');
  customS.className = 'color-custom';
  const inpS = document.createElement('input');
  inpS.type = 'color'; inpS.value = node.color;
  inpS.addEventListener('input', (e) => { e.stopPropagation(); applyColorSingle(node, e.target.value); });
  inpS.addEventListener('change', () => hideContextMenu());
  customS.appendChild(inpS);
  singleEl.appendChild(customS);
  // All (with children) color palette - only show if has children
  const allLabel = document.getElementById('ctx-color-all-label');
  const allEl = document.getElementById('ctx-colors-all');
  allLabel.style.display = hasChildren ? '' : 'none';
  allEl.style.display = hasChildren ? '' : 'none';
  allEl.innerHTML = '';
  if (hasChildren) {
    PALETTE.forEach(c => {
      const dot = document.createElement('span');
      dot.className = 'color-dot' + (c === node.color ? ' active' : '');
      dot.style.background = c;
      dot.addEventListener('click', (e) => { e.stopPropagation(); applyColorAll(node, c); hideContextMenu(); });
      allEl.appendChild(dot);
    });
    const customA = document.createElement('span');
    customA.className = 'color-custom';
    const inpA = document.createElement('input');
    inpA.type = 'color'; inpA.value = node.color;
    inpA.addEventListener('input', (e) => { e.stopPropagation(); applyColorAll(node, e.target.value); });
    inpA.addEventListener('change', () => hideContextMenu());
    customA.appendChild(inpA);
    allEl.appendChild(customA);
  }

  const delItem = ctxMenu.querySelector('[data-action="delete"]');
  delItem.style.display = node.id === DATA.id ? 'none' : '';
  const delSelItem = document.getElementById('ctx-del-sel');
  const selCount = selectedNodes.size;
  const eqWItem = document.getElementById('ctx-eq-w');
  eqWItem.style.display = selCount >= 2 ? '' : 'none';
  if (selCount >= 2) eqWItem.textContent = `↔ 選択 ${selCount} ノードの幅を揃える`;
  delSelItem.style.display = selCount >= 2 ? '' : 'none';
  if (selCount >= 2) delSelItem.textContent = `選択した ${selCount} ノードを削除`;
  ctxMenu.style.left = mx + 'px';
  ctxMenu.style.top = my + 'px';
  ctxMenu.classList.add('show');
}

function hideContextMenu() { ctxMenu.classList.remove('show'); ctxNode = null; }

document.addEventListener('click', (e) => {
  if (e.target.closest('.ctx-color-grid') || e.target.closest('.color-custom')) return;
  hideContextMenu();
});
document.addEventListener('contextmenu', (e) => {
  if (!e.target.closest('.node-group')) { hideContextMenu(); }
});

ctxMenu.addEventListener('click', (e) => {
  const action = e.target.closest('.ctx-item')?.dataset.action;
  if (!action || !ctxNode) return;
  e.stopPropagation();
  if (action === 'add') {
    const newNode = addChildNode(ctxNode);
    pendingEditNodeId = newNode.id;
    render(); updateTransform();
  } else if (action === 'align') {
    autoFormatSubtree(ctxNode);
  } else if (action === 'align-left') {
    alignSelectedLeft();
  } else if (action === 'toggle') {
    if (ctxNode.children && ctxNode.children.length > 0) {
      if (collapsed.has(ctxNode.id)) collapsed.delete(ctxNode.id);
      else collapsed.add(ctxNode.id);
      render();
    }
  } else if (action === 'delete') {
    if (ctxNode.id === DATA.id) return;
    pushUndo();
    const parent = findParent(ctxNode, DATA);
    if (parent) {
      parent.children = parent.children.filter(c => c.id !== ctxNode.id);
      customPos.delete(ctxNode.id); customWidth.delete(ctxNode.id);
      anchorOverrides.delete(`${parent.id}-${ctxNode.id}`);
      selectedNodes.delete(ctxNode.id);
      render(); updateTransform();
    }
  } else if (action === 'equalize-width') {
    if (selectedNodes.size >= 2) {
      pushUndo();
      let maxW = 0;
      for (const nid of selectedNodes) {
        const n = nodeMap.get(nid);
        if (!n) continue;
        const d = getNodeDepth(n);
        const w = customWidth.has(nid) ? customWidth.get(nid) : defaultNodeWidth(n, d);
        if (w > maxW) maxW = w;
      }
      for (const nid of selectedNodes) {
        customWidth.set(nid, maxW);
      }
      render(); updateTransform();
    }
  } else if (action === 'delete-selected') {
    pushUndo();
    for (const nid of [...selectedNodes]) {
      if (nid === DATA.id) continue;
      const n = nodeMap.get(nid);
      if (!n) continue;
      const p = findParent(n, DATA);
      if (p) {
        p.children = p.children.filter(c => c.id !== nid);
        customPos.delete(nid); customWidth.delete(nid);
        anchorOverrides.delete(`${p.id}-${nid}`);
      }
    }
    selectedNodes.clear();
    render(); updateTransform();
  }
  hideContextMenu();
});

// Pan & Zoom
const container = document.getElementById('container');
const viewport = document.getElementById('viewport');
let isPanning = false, panStartX = 0, panStartY = 0;

function updateTransform() {
  const cx = window.innerWidth / 2;
  const cy = window.innerHeight / 2;
  viewport.setAttribute('transform', `translate(${cx + viewX},${cy + viewY}) scale(${scale})`);
  saveState();
}

container.addEventListener('contextmenu', (e) => e.preventDefault());

// Rubber band / Pan
const selectBox = document.getElementById('select-box');
let isSelecting = false, selStartX = 0, selStartY = 0;

container.addEventListener('mousedown', (e) => {
  if (e.target.closest('.node-group') || e.target.closest('.anchor-dot')) return;
  hideContextMenu();
  hideArrowContextMenu();

  // Check if clicking on a free arrow handle
  const handle = e.target.closest('.free-arrow-handle');
  if (handle) {
    e.stopPropagation();
    e.preventDefault();
    const arrowId = Number(handle.dataset.arrowId);
    const handleType = handle.dataset.handleType;
    const arrow = freeArrows.find(a => a.id === arrowId);
    if (!arrow) return;
    pushUndo();
    const wcx = window.innerWidth / 2, wcy = window.innerHeight / 2;
    function onMove(ev) {
      const svgX = (ev.clientX - wcx - viewX) / scale;
      const svgY = (ev.clientY - wcy - viewY) / scale;
      if (handleType === 'start') { arrow.x1 = svgX; arrow.y1 = svgY; }
      else if (handleType === 'end') { arrow.x2 = svgX; arrow.y2 = svgY; }
      else if (handleType === 'control') { arrow.cx = svgX; arrow.cy = svgY; }
      renderFreeArrows(); saveState();
    }
    function onUp() {
      window.removeEventListener('mousemove', onMove);
      window.removeEventListener('mouseup', onUp);
    }
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
    return;
  }

  // Check if clicking on a free arrow path/hit area
  const arrowEl = e.target.closest('.free-arrow-hit') || e.target.closest('.free-arrow-path');
  if (arrowEl) {
    e.stopPropagation();
    e.preventDefault();
    if (e.button === 2) return; // handled by contextmenu
    const arrowId = Number(arrowEl.dataset.arrowId);
    selectedArrowId = (selectedArrowId === arrowId) ? null : arrowId;
    selectedNodes.clear();
    renderFreeArrows();
    return;
  }

  // Arrow drawing mode
  if (isArrowMode && e.button === 0 && !e.shiftKey) {
    e.preventDefault();
    const wcx = window.innerWidth / 2, wcy = window.innerHeight / 2;
    const startX = (e.clientX - wcx - viewX) / scale;
    const startY = (e.clientY - wcy - viewY) / scale;
    pushUndo();
    const newArrow = {
      id: freeArrowIdCounter++,
      x1: startX, y1: startY,
      x2: startX, y2: startY,
      cx: startX, cy: startY,
      color: arrowDrawColor,
      strokeWidth: 4,
    };
    freeArrows.push(newArrow);
    selectedArrowId = newArrow.id;

    function onMove(ev) {
      const svgX = (ev.clientX - wcx - viewX) / scale;
      const svgY = (ev.clientY - wcy - viewY) / scale;
      newArrow.x2 = svgX;
      newArrow.y2 = svgY;
      // Auto-set control point to midpoint during drawing
      newArrow.cx = (newArrow.x1 + svgX) / 2;
      newArrow.cy = (newArrow.y1 + svgY) / 2;
      renderFreeArrows();
    }
    function onUp(ev) {
      window.removeEventListener('mousemove', onMove);
      window.removeEventListener('mouseup', onUp);
      // Remove if too short (accidental click)
      const len = Math.hypot(newArrow.x2 - newArrow.x1, newArrow.y2 - newArrow.y1);
      if (len < 10) {
        freeArrows = freeArrows.filter(a => a.id !== newArrow.id);
        selectedArrowId = null;
        undoStack.pop(); // remove the undo snapshot
      }
      renderFreeArrows();
      saveState();
    }
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
    return;
  }

  // Deselect arrow on empty click
  if (selectedArrowId !== null) {
    selectedArrowId = null;
    renderFreeArrows();
  }

  if (e.shiftKey) {
    // Shift+drag = rubber band selection
    isSelecting = true;
    selStartX = e.clientX; selStartY = e.clientY;
    selectBox.setAttribute('visibility', 'visible');
  } else {
    // Normal drag = pan
    selectedNodes.clear(); render();
    isPanning = true;
    panStartX = e.clientX - viewX;
    panStartY = e.clientY - viewY;
    container.classList.add('grabbing');
  }
});

window.addEventListener('mousemove', (e) => {
  if (isPanning) {
    viewX = e.clientX - panStartX;
    viewY = e.clientY - panStartY;
    updateTransform();
  } else if (isSelecting) {
    const cx = window.innerWidth / 2, cy = window.innerHeight / 2;
    const x1 = (selStartX - cx - viewX) / scale;
    const y1 = (selStartY - cy - viewY) / scale;
    const x2 = (e.clientX - cx - viewX) / scale;
    const y2 = (e.clientY - cy - viewY) / scale;
    const rx = Math.min(x1, x2), ry = Math.min(y1, y2);
    const rw = Math.abs(x2 - x1), rh = Math.abs(y2 - y1);
    selectBox.setAttribute('x', rx);
    selectBox.setAttribute('y', ry);
    selectBox.setAttribute('width', rw);
    selectBox.setAttribute('height', rh);

    // Live-select nodes inside box
    selectedNodes.clear();
    for (const box of lastNodeBoxes) {
      if (box.x >= rx && box.x <= rx + rw && box.y >= ry && box.y <= ry + rh) {
        selectedNodes.add(box.id);
      }
    }
    render(); updateTransform();
    selectBox.setAttribute('visibility', 'visible');
  }
});

window.addEventListener('mouseup', () => {
  if (isSelecting) {
    isSelecting = false;
    selectBox.setAttribute('visibility', 'hidden');
    selectBox.setAttribute('width', 0); selectBox.setAttribute('height', 0);
    render();
  }
  isPanning = false;
  container.classList.remove('grabbing');
});

container.addEventListener('wheel', (e) => {
  e.preventDefault();
  const delta = e.deltaY > 0 ? 0.975 : 1.025;
  const newScale = Math.min(3, Math.max(0.2, scale * delta));
  // Zoom toward cursor
  const cx = window.innerWidth / 2;
  const cy = window.innerHeight / 2;
  const mx = e.clientX - cx - viewX;
  const my = e.clientY - cy - viewY;
  viewX -= mx * (newScale / scale - 1);
  viewY -= my * (newScale / scale - 1);
  scale = newScale;
  updateTransform();
}, { passive: false });

// Touch support
let lastTouchDist = 0;
let lastTouchX = 0, lastTouchY = 0;

container.addEventListener('touchstart', (e) => {
  if (e.touches.length === 1) {
    isPanning = true;
    panStartX = e.touches[0].clientX - viewX;
    panStartY = e.touches[0].clientY - viewY;
  } else if (e.touches.length === 2) {
    isPanning = false;
    lastTouchDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
    lastTouchX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
    lastTouchY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
  }
}, { passive: true });

container.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (e.touches.length === 1 && isPanning) {
    viewX = e.touches[0].clientX - panStartX;
    viewY = e.touches[0].clientY - panStartY;
    updateTransform();
  } else if (e.touches.length === 2) {
    const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
    const delta = dist / lastTouchDist;
    scale = Math.min(3, Math.max(0.2, scale * delta));
    lastTouchDist = dist;
    updateTransform();
  }
}, { passive: false });

container.addEventListener('touchend', () => { isPanning = false; });

// Controls
document.getElementById('zoomIn').addEventListener('click', () => {
  scale = Math.min(3, scale * 1.2);
  updateTransform();
});
document.getElementById('zoomOut').addEventListener('click', () => {
  scale = Math.max(0.2, scale * 0.8);
  updateTransform();
});
document.getElementById('autoFormat').addEventListener('click', () => {
  autoFormat();
});
document.getElementById('resetView').addEventListener('click', () => {
  resetAll();
  render();
  updateTransform();
});

// Arrow mode toggle
const arrowModeBtn = document.getElementById('arrowMode');
arrowModeBtn.addEventListener('click', () => {
  isArrowMode = !isArrowMode;
  arrowModeBtn.classList.toggle('active', isArrowMode);
  container.classList.toggle('arrow-mode', isArrowMode);
  if (!isArrowMode) { selectedArrowId = null; renderFreeArrows(); }
});

// Arrow context menu
const arrowCtxMenu = document.getElementById('arrow-ctx-menu');
let arrowCtxTarget = null;

function showArrowContextMenu(mx, my, arrow) {
  arrowCtxTarget = arrow;
  // Width options
  const widthsEl = document.getElementById('arrow-ctx-widths');
  widthsEl.innerHTML = '';
  const WIDTHS = [2, 4, 6, 8, 12];
  WIDTHS.forEach(w => {
    const opt = document.createElement('span');
    opt.className = 'width-opt' + ((arrow.strokeWidth || 4) === w ? ' active' : '');
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', '30'); svg.setAttribute('height', '16');
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', '2'); line.setAttribute('y1', '8');
    line.setAttribute('x2', '28'); line.setAttribute('y2', '8');
    line.setAttribute('stroke', '#fff'); line.setAttribute('stroke-width', w);
    line.setAttribute('stroke-linecap', 'round');
    svg.appendChild(line);
    opt.appendChild(svg);
    opt.addEventListener('click', (ev) => {
      ev.stopPropagation();
      pushUndo();
      arrow.strokeWidth = w;
      renderFreeArrows(); saveState();
      // Update active state
      widthsEl.querySelectorAll('.width-opt').forEach(el => el.classList.remove('active'));
      opt.classList.add('active');
    });
    widthsEl.appendChild(opt);
  });
  const colorsEl = document.getElementById('arrow-ctx-colors');
  colorsEl.innerHTML = '';
  PALETTE.forEach(c => {
    const dot = document.createElement('span');
    dot.className = 'color-dot' + (c === arrow.color ? ' active' : '');
    dot.style.background = c;
    dot.addEventListener('click', (ev) => {
      ev.stopPropagation();
      pushUndo();
      arrow.color = c;
      renderFreeArrows(); saveState();
      hideArrowContextMenu();
    });
    colorsEl.appendChild(dot);
  });
  // Custom color picker
  const custom = document.createElement('span');
  custom.className = 'color-custom';
  const inp = document.createElement('input');
  inp.type = 'color';
  inp.value = arrow.color;
  inp.addEventListener('input', (ev) => {
    ev.stopPropagation();
    pushUndo();
    arrow.color = ev.target.value;
    arrowDrawColor = ev.target.value;
    renderFreeArrows(); saveState();
  });
  inp.addEventListener('change', () => hideArrowContextMenu());
  custom.appendChild(inp);
  colorsEl.appendChild(custom);

  arrowCtxMenu.style.left = mx + 'px';
  arrowCtxMenu.style.top = my + 'px';
  arrowCtxMenu.classList.add('show');
}

function hideArrowContextMenu() { arrowCtxMenu.classList.remove('show'); arrowCtxTarget = null; }

// Arrow right-click on hit area / path
freeArrowsGroup.addEventListener('contextmenu', (e) => {
  const arrowEl = e.target.closest('.free-arrow-hit') || e.target.closest('.free-arrow-path');
  if (!arrowEl) return;
  e.preventDefault();
  e.stopPropagation();
  const arrowId = Number(arrowEl.dataset.arrowId);
  const arrow = freeArrows.find(a => a.id === arrowId);
  if (!arrow) return;
  selectedArrowId = arrowId;
  renderFreeArrows();
  showArrowContextMenu(e.clientX, e.clientY, arrow);
});

arrowCtxMenu.addEventListener('click', (e) => {
  const action = e.target.closest('.ctx-item')?.dataset.action;
  if (!action || !arrowCtxTarget) return;
  e.stopPropagation();
  if (action === 'arrow-delete') {
    pushUndo();
    freeArrows = freeArrows.filter(a => a.id !== arrowCtxTarget.id);
    selectedArrowId = null;
    renderFreeArrows(); saveState();
  }
  hideArrowContextMenu();
});

document.addEventListener('click', (e) => {
  if (!e.target.closest('#arrow-ctx-menu')) hideArrowContextMenu();
});

// Undo: Cmd+Z / Ctrl+Z  &  Delete/Backspace for selected arrow
window.addEventListener('keydown', (e) => {
  if ((e.metaKey || e.ctrlKey) && e.key === 'z') {
    e.preventDefault();
    undo();
  }
  if ((e.key === 'Delete' || e.key === 'Backspace') && selectedArrowId !== null) {
    // Don't delete arrow if user is editing a text input
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    e.preventDefault();
    pushUndo();
    freeArrows = freeArrows.filter(a => a.id !== selectedArrowId);
    selectedArrowId = null;
    renderFreeArrows(); saveState();
  }
  // Escape exits arrow mode
  if (e.key === 'Escape' && isArrowMode) {
    isArrowMode = false;
    arrowModeBtn.classList.remove('active');
    container.classList.remove('arrow-mode');
    selectedArrowId = null;
    renderFreeArrows();
  }
});

// Resize
window.addEventListener('resize', updateTransform);

// Top bar: page name & new page
const pageNameEl = document.getElementById('pageName');
let pageName = localStorage.getItem('mindmap_name') || 'SPA';
pageNameEl.textContent = pageName;
document.title = pageName;

pageNameEl.addEventListener('click', () => {
  const rect = pageNameEl.getBoundingClientRect();
  const input = document.createElement('input');
  input.type = 'text';
  input.className = 'name-edit-input';
  input.value = pageName;
  input.style.left = rect.left + 'px';
  input.style.top = rect.top + 'px';
  input.style.width = Math.max(200, rect.width) + 'px';
  input.style.height = rect.height + 'px';
  document.body.appendChild(input);
  input.focus();
  input.select();
  let committed = false;
  function commit() {
    if (committed) return;
    committed = true;
    const val = input.value.trim();
    if (val) {
      pageName = val;
      pageNameEl.textContent = val;
      document.title = val;
      localStorage.setItem('mindmap_name', val);
    }
    if (input.parentNode) input.remove();
  }
  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') { e.preventDefault(); commit(); }
    if (e.key === 'Escape') { committed = true; if (input.parentNode) input.remove(); }
  });
  input.addEventListener('blur', commit);
});

document.getElementById('newPageBtn').addEventListener('click', () => {
  if (!confirm('新しいページを作成しますか？\n現在の内容はリセットされます。')) return;
  resetAll();
  pageName = '新規ページ';
  pageNameEl.textContent = pageName;
  document.title = pageName;
  localStorage.setItem('mindmap_name', pageName);
  freeArrows = []; freeArrowIdCounter = 0; selectedArrowId = null;
  render();
  updateTransform();
  autoFormat();
});

// Init
render();
updateTransform();
if (isFirstLoad) {
  autoFormat();
  // Create white arrows connecting the main flow (top to bottom)
  const flowOrder = ['SPA開設', '教育', '会員ページ', 'ZOOM面談', '最終チェック'];
  const flowNodes = flowOrder.map(t => {
    for (const [, n] of nodeMap) { if (n.text === t) return n; }
    return null;
  }).filter(Boolean);
  for (let i = 0; i < flowNodes.length - 1; i++) {
    const src = flowNodes[i], dst = flowNodes[i + 1];
    if (src._x != null && dst._x != null) {
      freeArrows.push({
        id: freeArrowIdCounter++,
        x1: src._x, y1: src._y + 19,
        x2: dst._x, y2: dst._y - 19,
        cx: (src._x + dst._x) / 2, cy: (src._y + dst._y) / 2,
        color: '#ffffff', strokeWidth: 6,
      });
    }
  }
  renderFreeArrows();
  saveState();
}
</script>
</body>
</html>
